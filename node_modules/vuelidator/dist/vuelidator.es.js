import validator from 'validator';
import haye from 'haye/dist/haye.es';
import get from 'lodash/get';

function isExists(value) {
  if (value === null || value === undefined) {
    return false;
  } else if (Array.isArray(value)) {
    return value.length > 0;
  } else if (typeof value === 'string') {
    return value.trim().length > 0;
  } else if (value instanceof File) {
    return true;
  } else if (typeof value === 'object') {
    return Object.keys(value).length > 0;
  } else if (value instanceof Date) {
    return true;
  } else {
    return true;
  }
}

var validators = {
  alpha_numeric: function (value, args) {
    var options = args.length ? {
      locale: args[0]
    } : undefined;
    return validator.isAlphanumeric(value, options);
  },
  integer: function (value, args) {
    return validator.isInt(value);
  },
  isExists: isExists,
  length: function (value, args) {
    return validator.equals('' + value.length, args[0]);
  },
  lengthrange: function (value, args) {
    return validator.isLength(value, {
      min: args[0],
      max: args[1]
    });
  },
  min: function (value, args) {
    return validator.isLength(value, {
      min: args[0],
      max: undefined
    });
  },
  max: function (value, args) {
    return validator.isLength(value, {
      min: undefined,
      max: args[0]
    });
  },
  minval: function (value, args) {
    return validator.isFloat('' + value, {
      min: args[0],
      max: undefined
    });
  },
  maxval: function (value, args) {
    return validator.isFloat('' + value, {
      min: undefined,
      max: args[0]
    });
  },
  number: function (value, args) {
    return validator.isFloat('' + value);
  },
  required: isExists,
  phone: function (value, args) {
    return validator.isMobilePhone(value, args[0]);
  },
  regex: function (value, args) {
    var regexp = new RegExp(args[0], args[1]);
    return regexp.test(value);
  }
};
var validatorItems = ['after', 'alpha', 'base64', 'before', 'boolean', 'IP', 'IPRange', 'boolean', 'creditCard', 'currency', 'decimal', 'divisibleBy', 'empty', 'isHexColor', 'hexColor', 'hexadecimal', 'LatLong', 'lowercase', 'UUID', 'URL', 'uppercase', 'matches', 'PostalCode', 'port', 'JWT', 'JSON', 'hash', 'in', 'email', 'MD5', 'MACAddress'];
validatorItems.forEach(function (item) {
  validators[item.toLowerCase()] = function (value, args) {
    var name = 'is' + item.charAt(0).toUpperCase() + item.substr(1, item.length - 1);
    return validator[name](value, args.length ? args[0] : undefined);
  };
});

var parseFromString = function (rules) {
  return haye.fromPipe(rules).toArray();
};

var Validator = function Validator(rules, options) {
  if ( options === void 0 ) options = {};

  this.options = options;
  this.init(rules);
};

var prototypeAccessors = { isValid: { configurable: true } };

Validator.prototype.init = function init (rules) {
    var this$1 = this;

  this.errors = {};
  this.rules = {};
  this.handles = {};
  this.fields = [];
  Object.keys(rules).forEach(function (field) {
    var rule = rules[field];

    if (rule) {
      this$1.rules[field] = new ValidatorItem(rule, this$1);
      this$1.handles[field] = this$1.rules[field].handle;
      this$1.fields.push(field);
    }
  });
};

Validator.prototype.validateField = function validateField (field, value, silent) {
  var res = this.rules[field].validate(value);

  if (res !== true) {
    this.errors[field] = res;
    !silent && this.options.onError(field, res);
  } else {
    delete this.errors[field];
    !silent && this.options.onSuccess(field);
  }

  return res;
};

prototypeAccessors.isValid.get = function () {
  return !Object.keys(this.errors).length;
};

Validator.prototype.validate = function validate (data, silent) {
    var this$1 = this;

  var isValid = true;
  this.fields.forEach(function (field) {
    var value = get(data, field);
    var res = this$1.validateField(field, value, silent);
    isValid = isValid && res === true;
  });
  return isValid;
};

Object.defineProperties( Validator.prototype, prototypeAccessors );
var ValidatorItem = function ValidatorItem(rules, parent) {
  this.parent = parent;
  this.init(rules);
};

ValidatorItem.prototype.init = function init (rules) {
    var this$1 = this;

  if (typeof rules === 'string') {
    rules = parseFromString(rules);
  } else {
    var string_rules = rules.filter(function (rule) { return typeof rule === 'string'; }).join('|');
    rules = rules.filter(function (rule) { return typeof rule === 'object'; });

    if (string_rules) {
      rules = rules.concat(parseFromString(string_rules));
    }
  }

  this.hasRequired = !!rules.find(function (rule) { return rule.required || rule.name === 'required'; });
  this.rules = rules;

  this.handle = function (value) {
    return this$1.validate(value);
  };

  return rules;
};

ValidatorItem.prototype.validate = function validate (value) {
    var this$1 = this;

  if (!this.hasRequired && !validators.isExists(value)) {
    return true;
  }

  for (var rule of this$1.rules) {
    var validatorFn = rule.handle || validators[rule.name];

    if (!validatorFn) {
      console.warn('no validator', rule);
      continue;
    }

    if (!validatorFn(value, rule.args)) {
      return rule;
    }
  }

  return true;
};

var messages = {
  alpha: 'This field must contain only letters',
  alpha_numeric: 'This field must contain only letters and numbers',
  base64: 'Not valid base64 string',
  decimal: 'Field should be decimal',
  email: 'E-mail address should be valid',
  hash: 'Invalid hash',
  in: 'Not proper value',
  ip: 'Not valid ip address',
  json: 'Not valid json token',
  jwt: 'Not valid jwt token',
  lengthrange: 'Length should be from {0} to {1}',
  length: 'Length should be equal {0}',
  macaddress: 'Invalid MAC accdess',
  max: 'Length should be less than {0}',
  maxval: 'Value of field should be less than {0}',
  min: 'Length should be greater than {0}',
  minval: 'Value of field should be greater than {0}',
  md5: 'Invalid MD5 hash',
  number: 'Field should be number',
  postalcode: 'Invalid postal code',
  phone: 'Phone number should be valid',
  required: 'This field is required',
  uuid: 'Invalid uuid',
  regex: 'Not valid value'
};

var format = function (message, args) {
  if (!message) {
    return '';
  }

  return message.replace(/\{(\d+)\}/g, function (m, n) {
    return args[n] ? args[n] : m;
  });
};

function getMessage(rule, args) {
  return format(messages[rule], args);
}

var validatable = {
  created: function created() {
    if (this.validationRules) {
      this._validator = this.createValidator(this.validationRules, {
        watch: true
      });
    }
  },

  data: function data() {
    return {
      errors: {},
      successes: {},
      isValidationSuccess: undefined
    };
  },

  computed: {
    isValid: function isValid() {
      if (!this._validator) {
        return true;
      }

      if (this.isValidationSuccess === undefined) {
        this._validator.validate(this.$data, true);

        this.isValidationSuccess = this._validator.isValid;
      }

      return this.isValidationSuccess;
    },

    validationRules: function validationRules() {
      return null;
    },

    validationData: function validationData() {
      return this.$data;
    }

  },
  methods: {
    onValidationMessage: function onValidationMessage(ref) {
      var field = ref.field;
      var rule = ref.rule;

      if (this.$i18n && this.$t) {
        return this.$t(("validators." + (rule.name)), rule.args);
      } else {
        return getMessage(rule.name, rule.args);
      }
    },

    createValidator: function createValidator(rules, ref) {
      var this$1 = this;
      if ( ref === void 0 ) ref = {};
      var watch = ref.watch; if ( watch === void 0 ) watch = true;

      var validator$$1 = new Validator(rules, {
        onError: function (field, rule) {
          if (!rule.message) {
            rule.message = this$1.onValidationMessage({
              field: field,
              rule: rule
            });
          }

          this$1.$set(this$1, 'isValidationSuccess', false);
          this$1.$set(this$1.errors, field, rule.message);
          this$1.$set(this$1.successes, field, false);
        },
        onSuccess: function (field) {
          this$1.$set(this$1.errors, field, undefined);
          this$1.$set(this$1.successes, field, true);
          this$1.$set(this$1, 'isValidationSuccess', validator$$1.isValid);
        }
      });

      if (watch) {
        validator$$1.watchers = [];
        validator$$1.fields.forEach(function (field) {
          var wather = this$1.$watch(field, function (newVal, oldVal) {
            validator$$1.validateField(field, newVal);
          }); // {
          //   deep: true //  TODO review
          // })

          validator$$1.watchers.push(wather);
        });
      }

      return validator$$1;
    },

    validate: function validate(rules, data) {
      var validator$$1 = rules ? this.createValidator(rules, {
        watch: !data
      }) : this._validator; // if sent filed name

      if (typeof rules === 'string') {
        validator$$1.validateField(rules, get(this.validationData, rules));
      }

      if (validator$$1 instanceof Validator) {
        return validator$$1.validate(data || this.validationData);
      }
    }

  }
};

export { messages, validators, Validator as vuelidator, validatable as Validatable };
